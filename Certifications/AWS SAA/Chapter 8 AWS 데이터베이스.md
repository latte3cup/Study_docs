### RDBMS
데이터를 **테이블(표)** 구조로 저장하고, **관계(Relationship)** 를 통해 서로 연결하여 관리하는 데이터베이스 시스템

###### 특징
- **테이블 기반 구조**
    - 행(Row, 레코드)과 열(Column, 속성)으로 데이터 저장.
- **관계(Relation)**
    - 여러 테이블 간을 기본 키(Primary Key), 외래 키(Foreign Key)로 연결.
- **SQL(Structured Query Language)** 지원
    - 데이터 정의(DDL), 조작(DML), 제어(DCL)를 위한 표준 언어.
- **ACID 특성**
    - 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability) 보장 → 안정적인 트랜잭션 처리.

---
#### RDS 개요
##### DB 호스팅 시나리오
1. 온프레미스 데이터 센터에서 DB 호스팅 --> 서버 비용 및 관리 다 해야함
2. AWS EC2에 호스팅 --> 인프라 관련 비용만 없어지지만 RDBMS 관리에 대한 업무 수행
3. AWS RDS --> 인프라 관리 불필요, 즉각적 프로비저닝, 확장성, 비용효율성, 호환성, 고가용성, 보안유지

##### RDS 대신 EC2를 택하는 경우
-  DB 인스턴스에 대한 완전한 통제권을 원하는 경우
-  운영체제에 대한 통제권을 원하는 경우
-  백업, 복제 클러스터링에 대한 통제권을 원하는 경우
-  기업의 RDBMS 엔진의 주요 기능과 RDS와 맞지 않은 경우
- 기업이 요구하는 용량 성능이 RDS가 못미치는 경우

##### RDS의 고가용성 구현 (HA)
1. 싱글 AZ
2. 멀티 AZ : 스토리지가 복제되어 가용성 확보. DNS 문제 시 어짜피 엔드포인트 하나에서 분산

##### RDS의 확장성 구현
-  스케일업/다운 : 인스턴스 클래스 타입을 변경
-  스케일 아웃 & 인 : 
	- 읽기 복제본(Read Replica) -> 읽기 요청 분산으로 읽기 성능 향상
	  읽기 복제본은 복제 자체는 동기적이지만 동기적으로 이루어지지 않음
	  따라서 마스터 장애시 읽기 사본이 마스터로 되는 과정에서 데이터 손실 가능 -> 스탠바이 인스턴스를 둬야함
	- 특히 Aurora는 Auto Scaling 지원하나 읽기 복제본과 다를게 없음

#### RDS의 보안성 구현
1. 네트워크 수준 보안
	-  RDS는 VPC 위에서 배치 및 동작 되므로  VPC 네트워크 설정으로 접근 통제
	- 보안그룹, 네트워크 ACL 을 통해 방화벽 적용
2. 접근 제어
	- IAM 인증을  통해 DB 로그인 -> 패스워드 관리 부담 감소
	- Secret Manager/ Systems Manager Parameter Store 등을 통해 주기적으로 암호 회전 등
3. 데이터 보호 (암호화)
	- DB 인스턴스 스토리지, 백업, 읽기 사본, 스냅샷 등 모든 항복을 암호화 가능
	- RDS 암호화 구조는 이중 키 계층 (2-tier)
	- KMS로 RDS 데이터 키를 암호화함. 이유는 KMS는 비대칭키, RDS 데이터 키는 대칭키로 함으로써 성능 및 안전한 인증을 적용.
	- 또한 KMS 마스터키만 교체함으로써 데이터 전체를 다시 암복호화 할필요 없이 데이터키만 함으로써 재암호화됨
###### 특징
1. RDS 생성시에만 암호화 적용 가능. 변경을 원하면 마이그레이션 해야함
2. 한번 암호화를 한 인스턴스는 암호화 해제 불가.
3. 마스터 베이스와 읽기 사본은 반드시 암호화해야함 (동일한 키로 암호화 됨)
4. KMS가 리전별 서비스 이므로 RDS를 다른 리전으로 복사 불가


##### 백업, 복구, 스냅샷
#####  백업 (Backup)
- **자동 백업(Automated Backup)**
    - RDS가 제공하는 기본 기능.
    - 특정 보관 기간(최대 35일)을 설정하면 → 그 기간 동안 **지속적으로 트랜잭션 로그 + 하루 1회 전체 스냅샷**을 관리.
    - 이 조합으로 **Point-in-Time Recovery (PITR)** 가능.
        - 예: “어제 오후 3시 25분 시점으로 DB 복구해줘” 가능.
    - 백업은 S3에 안전하게 저장됨 (사용자 직접 접근은 불가).
- **특징**
    - 인스턴스 삭제 시 자동 백업도 함께 제거됨.
    - 보관 기간을 0으로 설정하면 자동 백업 꺼짐.
##### 스냅샷 (Snapshot)
- **수동 스냅샷(Manual Snapshot)**
    - 사용자가 필요할 때 직접 생성하는 백업.
    - 보존 기한 제한 없음 → 사용자가 지우기 전까지 계속 유지.
    - 다른 AWS 계정이나 리전에 공유/복사 가능 (단, 암호화된 경우 KMS 키 권한 필요).
- **특징**
    - 인스턴스 삭제 후에도 스냅샷은 남음.
    - 스냅샷을 기반으로 새 DB 인스턴스 생성 가능.
    - 암호화 여부는 원본을 그대로 따름 (암호화된 스냅샷 → 암호화된 복원).
##### 복구 (Restore)
- **자동 백업에서 복구**
    - 설정된 보관 기간 내에서 **임의의 시점(PITR)**으로 복구 가능.
    - 새로운 DB 인스턴스가 생성되며, 원본과 별도로 동작.
- **스냅샷에서 복구**
    - 수동/자동 스냅샷을 기반으로 DB 인스턴스를 새로 생성.
    - 복원 후 독립된 인스턴스가 되므로, 원본 DB와는 분리되어 있음.

##### 모니터링
###### 기본 모니터링 (기본 지표, CloudWatch)
- RDS는 기본적으로 **CloudWatch 지표(Metrics)** 를 1분 단위로 제공합니다.
- 대표 지표:
		- **CPUUtilization** (CPU 사용률)
		- **FreeableMemory** (사용 가능 메모리)
		- **FreeStorageSpace** (남은 스토리지 공간)
		- **ReadIOPS / WriteIOPS** (디스크 I/O)
		- **DatabaseConnections** (DB 연결 수)
		- **ReplicaLag** (읽기 복제본 지연 시간)
- 장점: 기본 제공, 추가 비용 없음.
- 한계: DB 엔진 내부 상태(쿼리, 버퍼 캐시 등)는 보이지 않음.
###### 향상된 모니터링 (Enhanced Monitoring)
- OS 레벨 지표를 최대 1초 간격으로 수집.
- 약 총 50개의 지표
- CloudWatch가 아니라 **CloudWatch Logs**에 저장됨.
- 예: CPU 커널/유저 모드 분리, 스왑 사용량, 디스크 IOPS 세부 값, 네트워크 패킷 단위.
- → 인스턴스 내부 리눅스 OS 상태까지 가시성 확보.
###### 퍼포먼스 인사이트 (Performance Insights)
- DB 엔진 내부의 **쿼리 성능 및 부하 분석 도구**.
- AAS(Average Active Sessions, 평균 활성 세션) 기준으로 병목 지점을 보여줌.
- 기능:
    - 어떤 SQL이 CPU/I/O 부하를 많이 차지하는지 식별.
    - Wait event 분석 (락 대기, I/O 대기 등).
    - 시각화된 대시보드 제공 (병목 원인 파악에 유용).
- 지난 15분간의 데이터를 보여주며 (60분까지 가능) , 35일간 보관
##### RDS 이벤트 노티피케이션
- SNS와 연동하여 알림 전송

----
#### Amazon Aurora
- **클라우드 네이티브 관계형 데이터베이스(RDBMS)** 로, **MySQL·PostgreSQL과 호환**되면서도 **고성능·고가용성·자동 확장** 기능을 제공
##### 핵심 특징
- **호환성**: MySQL, PostgreSQL 엔진과 호환 → 기존 앱/도구 그대로 사용 가능.
- **성능**: 같은 하드웨어에서 표준 MySQL 대비 최대 5배, PostgreSQL 대비 최대 3배 성능.
- **스토리지 아키텍처**:
    - 데이터를 **6중 복제(3개 AZ에 2개씩)** 저장.
    - 스토리지는 자동으로 확장(최대 128TB).
- **고가용성**
	- 장애 발생 시 자동 Failover → Reader를 Writer로 승격. 거의 실시간. 데이터 손실 위험 거의 없음
- **보안**: VPC, KMS 암호화, TLS, IAM 인증 지원.
- **서버리스 옵션**: Aurora Serverless → 워크로드에 따라 자동으로 인스턴스 크기/수량 조정.
##### 클러스터 구조
- **Writer Node (Primary)**
    - 유일한 쓰기 가능 인스턴스.
    - 읽기도 가능하지만, 쓰기 부하 집중.
- **Reader Node (Replica)**
    - 읽기 전용. 최대 15개까지 추가 가능.
    - Auto Scaling으로 트래픽에 따라 증감 가능.
    - **완전 동기적 복제**
- **공유 스토리지**
    - Writer/Reader가 동일한 분산 스토리지 계층을 사용.
    - 복제 지연을 최소화
    - 4개 이상 성공 시 커밋 -> 지연 최소

---
#### Amazon Redshift
- 완전관리형(Managed) 데이터 웨어하우스(DW, Data Warehouse) 서비스
- **OLAP(Online Analytical Processing)** 전용 데이터베이스
- **대규모 데이터 분석용 RDBMS**, PostgreSQL 기반, SQL 그대로 사용 가능
- EC2 기반 으로 동작 . 다만 직접 제어 불가능함. 관리형 서비스로 제공
- Redshift Spectrum으로 s3에 존재하는 데이터를 실제 존재하는 것처럼 쿼리
##### 장점
1. 신속성 : 칼럼형 스토리지 키반으로 높은 쿼리 성능 , IO 효율성
2. 저렴함 : 테라바이트당 $1000 수준
3. 우수한 압축성 -> 비용 절감
4. 관리형 서비스 : 클러스터 , 네트워킹, 운영체제 AWS가 관리
5. 확장성 : 분산형 병렬식 아키텍처 : 처리 성능을 스케일 아웃으로 제공
6. 보안성 : KMS와 HSM을 이용해 키 관리
7. 존 맵 기능(Zone mpas) : 각 블록의 최대 최소 값을 추적해 쿼리 대상에 제외하여 쿼리 성능 향상 및 IO 감소
##### 아키텍처 특징
- **클러스터 구조**
    - Leader Node: 쿼리 파싱·계획·분산 작업(라우팅 잡) 조정. (명령을 내림)
    - Compute Nodes: 실제 데이터 저장 및 병렬 처리.
	    - 각 노드는 슬라이스 단위로 나뉨
	    - 노드의 CPU, 메모리, 디스크를 여러 슬라이스로 분리
- **MPP (Massively Parallel Processing)**
    - 데이터를 여러 노드·슬라이스에 분산 저장 → 동시에 병렬 처리 → 고속 쿼리 성능.
- **컬럼 기반 저장(Columnar Storage)**
    - 행(Row) 단위가 아닌 열(Column) 단위로 저장.
    - 분석 쿼리에 필요한 열만 읽어 성능과 압축률 대폭 향상.
- **데이터 압축·인덱스 최적화**
    - 자동 압축으로 저장 공간 절약.
    - 복잡한 인덱스 없이 분산키·정렬키 설계로 성능 최적화.
##### 데이터 흐름 (Query Execution Flow)
1. 사용자가 SQL 쿼리를 Leader Node에 전달.
2. Leader Node가 실행 계획(Execution Plan) 생성.
3. 쿼리를 작은 작업 단위로 나눠 Compute Node에 분배.
4. 각 Compute Node가 자신이 가진 데이터 파티션을 병렬 처리.
5. 결과를 Leader Node로 전송.
6. Leader Node가 결과를 병합·집계 후 사용자에게 반환.

##### 네트워킹
- 기본적으로 vpc 내에서 실행되므로 vpc 특징을 고스란히 받음
- 추가특징
	1. Enhanced VPC Routing 
		-  클러스터와 데이터 리포지토리 사이의 COPY 및 UNLOAD 트래픽이 모두 VPC 라우팅 테이블을  통과하도록 강제
		- 이로써 트래픽 경로 투명성 향상, 
		- VPC 엔드포인트 활용 가능(트래픽이 인터넷을 안거침)
	2. Redshift VPC Endpoints (PrivateLink)
		- Redshift에 **프라이빗 엔드포인트**를 붙여 전용 프라이빗 경로 제공
	3. Federated Query / Redshift Spectrum 네트워킹
		- Redshift ↔ S3 ↔ Glue Catalog ↔ 다른 RDS/Aurora 연결 시, 전부 VPC 경로를 통해 설정 가능
		- 즉 외부 DB를 클러스터 내부의 리소스처럼 사용 가능

##### 암호화
- 기본적으로는 RDS의 암호화와 대부분 동일함
- 생성시에만 암호화 등등
- 한번 암호화가 켜진 클러스터는 데이터파일, 스냅샷, 자동 백업도 모두 암호화됨
- AWS KMS, AWS CloudHSM, 온프레미스  HSM 등으로 암호화 키 관리.

#### 보안
- Redshift는 RDMBS 중 하나(Postgre 기반)이므로 슈퍼 유저 또는 유저 퍼미션을 지닌 DB 유저를 생성해야함.
- 생성 시 마스터 유저네임과 패스워드를 생성함. (생성 후 삭제 불가)

##### 백업 및 복구
- 스냡샷 형태로 자동화된 백업 생성하여 S3에 저장
- 기본 1일 ~ 35일까지, 원하는 시점 복구
- 증분 백업 및 멀티 리전 복제
- 수동 스냅샷은 영구 보존

##### Amazon Redshift에서 데이터 로딩하기
1. 파일 기반 로딩  (COPY 명령)
	- CSV, JSON, format , delimeter, shapefile, fixed-width, Avro, Parquet, ORC 등
	- MPP 방식으로 로딩함
2. INSERT 명령 ( 표준 SQL )
	- 소규모 적합. 대량 데이터에는 비효율적
3. 데이터 파이프라인
	- Glue, AWS DMS, AWS Data Pipeline 등으로 적재

- UNLOAD 명령 : 데이터를 내보내는거 파일을 생성해서 S3에 저장
- VACUUM 
	- 분산 및 컬럼 기반이므로 죽은 레코드가 남고, 정렬이 약간씩 흐트러짐
	- 이를 위해 재정렬 및 공간 회수 작업을 수행
	- APPEND 만 하는 테이블에는 당연히 효과 없음
	- 트랜잭션이 많은 테이블만 효과적
		- **VACUUM FULL**
		    - 테이블 전체를 재정렬 + 디스크 공간 회수.
		    - 가장 무겁고 오래 걸리지만 효과 확실.
		- **VACUUM SORT ONLY**
		    - 정렬만 수행, 공간 회수는 하지 않음.
		- **VACUUM DELETE ONLY**
		    - 삭제된 튜플 공간만 회수. 정렬은 그대로 둠.
		- **VACUUM REINDEX**
		    - 인덱스만 재구성.

##### Redshift 데이터 배분 전략
- **MPP(Massively Parallel Processing)** 구조라서, 데이터를 여러 **노드 → 슬라이스**에 어떻게 나눌지가 성능에 직결

###### (1) **AUTO (자동, 기본값)**
- Redshift가 테이블 크기와 쿼리 패턴을 기반으로 **EVEN, KEY, ALL 중 최적 스타일을 자동 선택**.
- 새로 생성된 테이블은 AUTO가 기본값 → 관리 부담 줄임.
###### (2) **EVEN (균등 분산)**
- 데이터를 **슬라이스별로 균등하게 랜덤 분산**.
- 장점: 데이터가 균형 있게 분산 → 병렬 처리 효율적.
- 단점: 조인 시 관련 데이터가 다른 노드에 흩어져 있으면, 네트워크를 통한 **Data Redistribution(재배분)** 발생 → 성능 저하.
- 적합: 작은 참조 테이블, 조인 관계가 적은 데이터.
###### (3) **KEY (키 기반 분산)**
- 특정 컬럼(Distribution Key, DISTKEY)의 **값을 기준**으로 해시(Hash) → 해당 값이 같은 로우는 같은 슬라이스에 저장.
- 장점: 조인/집계 시 같은 키 기준이면 같은 노드에서 처리 → **네트워크 이동 최소화, 성능 향상**.
- 단점: 키 분포가 불균형하면 **데이터 스큐(skew, 한쪽 노드에 쏠림)** 발생.
- 적합: 대규모 Fact 테이블, 자주 조인되는 키(예: customer_id, order_id).
###### (4) **ALL (복제 분산)**
- 전체 테이블을 **모든 노드에 복제**.
- 장점: 조인 시 네트워크 이동 필요 없음 → 빠름.
- 단점: 큰 테이블은 노드마다 중복 저장 → 저장 공간 낭비, 로딩 느려짐.

##### 정렬
Redshift의 정렬은 물리적인 데이터가 데이터블록에 실제로 정렬됨을 의미한다.

---
#### Amazon DynamoDB
- **완전관리형(Managed) NoSQL 데이터베이스** 서비스
- **Key-Value 및 Document 기반** NoSQL DB
- AWS가 인프라, 확장, 백업, 보안을 모두 관리

##### 주요 특징
(1) **완전관리형 (Fully Managed)**
- 서버 관리, 패치, 샤딩(데이터 분할), 복제 등을 AWS가 자동 처리.
- 사용자는 스키마 없는 테이블 정의와 API 호출만 수행.
(2) **무한 확장성 (Scalability)**
- 데이터 크기와 트래픽이 커져도 자동으로 파티셔닝 및 샤딩 수행.
- 수백 테라바이트 이상도 처리 가능.
(3) **고가용성 (High Availability)**
- 기본적으로 3개 가용영역(AZ)에 데이터 복제 저장.
- 단일 장애 지점(Single Point of Failure) 없음.
(4) **유연한 데이터 모델**
- **테이블(Table)** 단위로 관리.
- **파티션 키(Partition Key)**, **정렬 키(Sort Key)** 조합으로 아이템(Item) 접근.
- JSON 문서처럼 반정형 데이터도 저장 가능.
(5) **성능 선택 가능**
- **Provisioned Mode**: 읽기/쓰기 처리량을 미리 정해두는 방식.
- **On-Demand Mode**: 요청이 있을 때 자동으로 확장, 사용량만큼 과금.
(6) **보안**
- 암호화(KMS), IAM 권한 제어, VPC 엔드포인트 지원.
(7) 통합
- DynamoDB Streams : 
	- 테이블에서 발생하는 **데이터 변경(Insert, Update, Delete)** 이벤트를 **시간 순서대로 기록**하는 기능
	- 스트림의 레코드에는 변경 전/후의 데이터를 담을 수 잇음
	- 최대 24시간 동안만 유지
	- API 제공으로써 접근 및 사용
- 글로벌 테이블 (Global Tables) 
	- DynamoDB 테이블을 여러 리전에 자동으로 복제
	- 즉 멀티리전 ACTIVE-ACTIVE 구조
	- 내부적으로 Streams 를 활용해 복제 동작
- DynamoDB Accelerator (DAX)
	- DynamoDB 앞단에 두는 **인메모리 캐시(In-Memory Cache)** 서비스
	- 자주 읽는 데이터(읽기 요청)를 메모리에서 바로 반환 → **마이크로초 단위 응답**
	- 이를 넣어 성능 향상을 위한 애플리케이션 수정이 필요 없어짐
- Lambda와 통합해 트리거 생성 등

##### 주요 개념 및 용어
###### 1. 테이블(Table)
- DynamoDB에서 데이터를 담는 가장 큰 단위.
- 스키마가 고정되지 않고, **기본 키(Primary Key)** 만 반드시 정의하면 됨.
- RDBMS의 테이블과 비슷하지만, 각 행(Item)이 다른 속성(Attribute)을 가질 수 있음.
###### 2. 아이템(Item)
- 테이블에 저장되는 하나의 **레코드(Row)**.
- JSON 문서 형태처럼 자유롭게 여러 속성을 가질 수 있음.\
- 즉 하나의 JSON 객체가 하나의 아이템
- DynamoDB는 **Item 단위로 CRUD(Create, Read, Update, Delete)** 작업 수행.
- 최대 **400KB** 크기 제한
- 중첩 구조 지원
###### 3. 속성(Attribute)
- 아이템을 구성하는 **컬럼(Column)**.
- 문자열(String), 숫자(Number), 리스트(List), 맵(Map) 등 다양한 데이터 타입 가능.
- 같은 테이블의 아이템이라도 속성 구조가 달라도 됨.
###### 4. 기본 키(Primary Key)
DynamoDB의 데이터 검색은 항상 **기본 키 기반**으로 동작합니다.
- **단일 파티션 키(Partition Key Only)**
    - 예: `UserID` 하나만 키로 사용.
    - 동일한 `UserID` 값은 중복 불가.
- **복합 키(Partition Key + Sort Key)**
    - 예: `(UserID, OrderID)`
    - 같은 `UserID` 내에서 `OrderID` 값으로 여러 아이템 구분 가능.
    - 시계열 데이터 저장에 적합.
- JSON과 다르게 반드시 키가 있어야함
###### 5. 파티션 키(Partition Key) (hash attribute)
- DynamoDB 내부에서 데이터를 저장할 물리적 파티션을 정하는 기준.
- 해시(Hash) 함수로 값이 분배됨 → 확장성과 분산성 보장.
- 데이터 액세스 성능을 좌우하는 가장 중요한 키.
- 항상 기본키의 일부가 되거나 전체가 됨.
- 반드시 하나의 속성만 가짐
###### 6. 정렬 키(Sort Key)
- 같은 파티션 키 안에서 데이터를 정렬하는 기준.
- 범위 쿼리(`BETWEEN`, `<`, `>`)가 가능.
- 예: `UserID = 101` 안에서 `OrderDate` 기준으로 최근 주문만 조회.
###### 7. 보조 인덱스(Secondary Index)
- 기본 키 외에 다른 속성으로도 빠르게 검색 가능하게 만드는 인덱스.
- **LSI (Local Secondary Index)**: 같은 파티션 키 + 다른 Sort Key.
- **GSI (Global Secondary Index)**: 전혀 다른 파티션 키 + Sort Key.
- 인덱스를 쓰면 유연한 조회 가능.
###### 8. 프로비저닝(Provisioning) & 용량 모드
- **Provisioned Mode**
    - 초당 읽기/쓰기 처리량(RCU, WCU)을 미리 설정.
- **On-Demand Mode**
    - 요청량에 따라 자동 확장 → 사용량만큼 비용 지불.
###### 9. 읽기 일관성 옵션
###### (1). Eventually Consistent Read (최종적 일관성 읽기, 기본값)
- **특징**
    - 읽기 요청 시, 최근 쓰기(Write)가 즉시 반영되지 않을 수 있음.
    - 데이터가 복제본 전체에 전파(propagation)되면서 짧은 지연 발생.
    - 짧게는 밀리초 단위, 길어야 수 초 내에 모든 복제본이 최신 상태로 수렴.
- **장점**
    - 처리량(Throughput)과 성능이 높음.
    - 읽기 요청 1회가 “0.5 RCU(Read Capacity Unit)” 만 소모됨.
- **적합 사례**
    - 실시간으로 100% 최신 데이터가 필요하지 않은 경우.
    - 예: 뉴스 기사 조회, 제품 카탈로그 등.
###### (2). Strongly Consistent Read (강력한 일관성 읽기)
- **특징**
    - 읽기 시 항상 “성공적으로 커밋된 최신 데이터”를 반환.
    - 즉, 클라이언트가 직전에 기록한 데이터가 반드시 보임.
- **장점**
    - 최신 데이터를 반드시 확인 가능.
- **단점**
    - 읽기 지연(latency)이 증가할 수 있음.
    - 읽기 요청 1회가 “1 RCU”를 소모.
    - 다중 리전(Global Table) 환경에서는 지원 안 됨.
- **적합 사례**
    - 금융 거래 내역, 사용자 설정값, 순위 같은 최신성이 중요한 데이터.
```
	쓰기 용량 유닛의 수(WCU) = 초당 쓰기 아이템 수 X 아이템 용량 (최대 1KB)
	읽기 용량 유닛의 수(RCU) = 초당 읽기 아이템 수 X 아이템 용량 (최대 4KB)
```

##### 암호화 및 보안
- 기본적인 AWS가 공통적으로 제공하는 보안은 다 똑같음
- DynamoDB가 다른 서비스와 차별점은
	- 아이템 수준 접근 제어 : 특정 파티션 키 값을 가진 아이템에 대해서만 접근 허용
	- 자동 암호화 : 선택이 아님 자동적으로 필수적으로 적용됨
	- 완전한 서버리스 이므로 계정 및 유저 설정 없음.

---
#### Amazon ElasticCache
- **완전관리형 인메모리 데이터 스토어 및 캐시 서비스**.
- 오픈소스 **Redis** 와 **Memcached** 엔진을 지원.
- 데이터를 디스크 대신 **메모리(RAM)** 에 저장하기 때문에 지연 시간이 매우 짧고, 초당 수백만 건 이상의 요청을 처리할 수 있음.
- 주로 **DB 부하 경감, 세션 관리, 실시간 분석, 메시지 큐 대체** 등에 활용. 
- **고가용성 & 복제**
	- **Multi-AZ 클러스터** 구성 가능.
	- Redis는 리더-리더, 리더-리플리카 구조 지원 → 장애 시 자동 페일오버.

##### 지원 엔진
	(1) Redis
	- Key-Value 저장 + 풍부한 자료구조 지원(List, Set, Sorted Set, Hash 등).
	- Pub/Sub, Lua 스크립팅, 트랜잭션, TTL 기능 포함.
	- 세션 스토어, 리더보드, 실시간 분석에 적합.
	- 고가용성(Replication, Auto-Failover) 지원.
	(2) Memcached
	- 단순 Key-Value 캐시.
	- 멀티스레드 지원 → 매우 빠른 단순 캐싱 용도에 적합.
	- 스케일아웃(Scale-Out) 쉬움, 복잡한 기능은 없음.

-----
#### Amazon Neptune
- **완전관리형 그래프 데이터베이스(Graph Database)** 서비스
- ACID 조ㅓ건 충족
##### 핵심 개념
- **그래프 DB**: 데이터를 **노드(Node)** 와 **엣지(Edge)** 로 저장하고, 노드와 노드 사이의 **연결 관계(Relationship)** 를 탐색하는 데 최적화된 데이터베이스.
- Amazon Neptune = **AWS 관리형, 고성능, 고가용성 그래프 DB**.
- 특징: **연결 중심 데이터**를 빠르게 처리할 수 있음.
##### 지원 데이터 모델
Neptune은 두 가지 그래프 모델을 지원합니다.
1. **Property Graph 모델**
    - 노드와 엣지에 속성을 부여 가능.
    - 쿼리 언어: **Apache TinkerPop Gremlin**.
2. **RDF(Resource Description Framework) 모델**
    - 데이터를 “주어-술어-목적어(Triple)” 형식으로 표현.
    - 쿼리 언어: **SPARQL**.
👉 이중 모델 지원은 Neptune의 큰 특징.

##### 활용 전략
- 소셜 네트워크
- 추천 시스템
- 지식 그래프
- 네트워크/ IT 운영 및 데이터 센터 관리
- 생명과학
- 경로 최적화 연구
- 사기행위 분석 등

---
#### Amazon DocumentDB
- **완전관리형 문서(Document) 데이터베이스** 서비스
- **MongoDB 호환 API** 를 제공하는 문서 지향(Document-oriented) DB.
- 데이터를 **JSON 문서 형식**으로 저장하고 쿼리할 수 있음.
- AWS에서 **확장성, 고가용성, 보안**을 갖춘 관리형 서비스로 제공.
- 목적: MongoDB 오픈소스를 직접 운영하지 않고, 클라우드 네이티브 방식으로 사용 가능하게 함.
##### 데이터 모델
(1) 문서(Document)
- MongoDB의 기본 저장 단위.
- JSON과 비슷하지만, 내부적으로는 **BSON(Binary JSON)** 포맷을 사용.
- 예시:
```
	`{
	  "user_id": 101,
	  "name": "Alice",
	  "age": 30,
	  "orders": ["book", "pen"],
	  "address": { "city": "Seoul", "zip": "12345" }
	}
```
(2) 컬렉션(Collection)
- 문서(Document)들의 집합.
- RDBMS의 “테이블”에 해당.
- 같은 컬렉션 안에서도 문서 구조가 달라도 됨.
(3) 데이터베이스(Database)
- 컬렉션(Collection)의 집합.

##### 주요 특징
(1) 스키마리스(Schema-less)
- 필드 구조가 문서마다 달라도 허용.
- 유연한 구조로 빠른 개발 가능.
(2) 풍부한 쿼리 언어
- SQL 대신 JSON 기반 쿼리 문법 사용.
- 조건 검색, 범위 검색, 집계(Aggregation Framework), 정렬, 인덱싱 지원.
(3) 확장성(Scalability)
- 수평 확장(Sharding) 지원.
- 데이터가 커지면 여러 서버에 분산 저장 가능.
(4) 고가용성(High Availability)
- Replica Set 기능: 동일 데이터를 여러 노드에 복제.
- 장애 발생 시 자동 Failover.
(5) 다양한 사용 사례
- IoT 로그, 소셜 네트워크, 전자상거래 카탈로그, CMS, 모바일 앱 데이터 저장.
- 실시간 빅데이터 처리