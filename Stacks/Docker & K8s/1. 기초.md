### 이미지 
도커 이미지의 구조

2. 이미지 인덱스 : 이는 이미지 자체에 포함된 내용이 아닌 도커 허브 레지스트리에 있는 정보
 - 각 아키텍처에 따르는 이미지별 digest가 이미지 인덱스가 된다.
  
0. Layers (Blob) : 실제 파일 데이터 저장소 (tar.gz 형태)
1. Manifest : 어떤 레이어들을 어떤 순서로 합칠지 정의하는 메타데이터
2. Config : 이미지 자체의 설정 값들 (env, cmd, entrypoint,working dir 등)

### 네트워크
도커 컨테이너 네트워크 구조

컨테이너 내부에서 ifconfig 실행 
1. Eth0 : 컨테이너 내부 이더넷 (NIC) : 컨테이너 내부에서 활용할 수 있는 ip
2. lo (Loopback): 로컬 ip 자기 자신을 의미하는 ip로 , 컨테이너 자신이 가진 ip 이다.
어짜피 이 2개는 도커 호스트 위에 존재하므로 내부 아이피이다.

wsl 상(호스트 머신)에서 ifconfig 실행
1. docker0 : 할당된 모든 컨테이너에 접근할 수 있는 서브넷 ip (내부 Ip 이므로 호스트 ip에서만 접근 가능)
2. eth0 : 여기서는 실제 물리 NIC의 주소, 실제 외부 주소와 통신할 수 있는 주소
3. Lo : wsl (우분투)를 가르키는 주소
4. veth8601cf6 :도커 엔진과 컨테이너의 Eth0을 연결 시켜주는 가상 케이블

※ enp0s3 와 같은 것은 리눅스 NIC로, 나는 wsl을 사용중이므로 안나옴
하지만 VM 을 리눅스로 올린다면 나타날 수 있음

##### 브리지 네트워크
 : 일단 하나의 논리적인 네트워크, 서브넷으로 구성함
 - 도커에서 처음 컨테이너 생성 시  docker0이라는 브리지 네트워크를 최초로 하나 만들면 이를 사용
 - 그후 따로 설정하지 않는 이상 컨테이너는 계속 이 브리지 네트워크를 사용 
 - 도커 엔진이 모든 컨테이너든 접근할 수있는 ip 주소 (기본적으로)
 - 이 브리지 네트워크 안의 모든 컨테이너들끼리는 통신 가능
 - 이 브리지 네트워크에서 컨테이너들은 하나씩 Ip주소를 할당 받는것



#### 호스트와 컨테이너 사이의 파일 전송
1. 호스트 --> 컨테이너
	docker container cp "[출발 경로/보내고 싶은 파일 명]""[도착 컨테이너 ID: 저장 경로]"
2. 컨테이너 --> 호스트
	docker container cp "[도착 컨테이너 ID: 저장 경로]""[출발 경로/보내고 싶은 파일 명]"

 2번에서 특히 주의할점은 컨테이너에서 호스트로 간다고 컨테이너 입출력 스트림에서 실행하지는 않는다.
 애초에 Docker 명령어를 쓰는데 컨테이너 안에는 docker가 없기 때문



### 도커 스토리지
	도커 컨테이너는 언젠가는 삭제되기 떄문에 도커 컨테이너의 파일을 보존하기 위한 스토리지

##### 내부 (기본 값)
- 도커 컨테이너에 생성되는 파일 시스템 즉, Overlay2 폴더에서 관리되는 시스템
- 이는  당연히 컨테이너에 종속적이므로 컨테이너 삭제 시 이 파일도 사라짐

##### 외부 (도커 스토리지) 종류
1. Volume
2. Bind Mount
3. tmpfs

| 항목                | Volume                                        | Bind Mount                      | tmpfs Mount               |
| ----------------- | --------------------------------------------- | ------------------------------- | ------------------------- |
| 저장 위치             | Docker 내부 관리 디렉토리 (`/var/lib/docker/volumes`) | 호스트의 **지정한 실제 디렉토리**            | RAM (메모리)                 |
| 생성 방식             | `docker volume create` 또는 `-v volume:/path`   | `-v /host/path:/container/path` | `--tmpfs /container/path` |
| 컨테이너 종료 후         | **데이터 유지**                                    | **데이터 유지**                      | 데이터 **사라짐**               |
| 관리 주체             | Docker가 자동 관리                                 | 사용자가 직접 디렉토리 지정                 | 메모리에 임시 저장                |
| 보안성               | 격리되어 안전함                                      | 호스트 파일 직접 노출됨                   | 매우 안전 (휘발성)               |
| 사용 용도             | DB, 로그, 앱 데이터                                 | 소스 코드, 설정 파일                    | 암호/세션, 속도 요구              |
| 이식성               | 좋음                                            | 낮음 (호스트 종속)                     | 무의미 (RAM 기반)              |
| Docker Compose 지원 | ✅ 좋음                                          | ✅ 좋음                            | ⚠️ 제한적                    |
| 퍼포먼스              | 디스크 I/O                                       | 디스크 I/O                         | 매우 빠름 (RAM)               |

1. Volume
	$ docker run -e POSTGRES_PASSWORD=mysecretpassword --mount type=volume,source=myvolume01,target=/var/lib/postgresql/data -d postgre
- 이러면 새로운 컨테이너 생성 시에도 동일한 DB로 인식 할 수 있음

1. Bind Mount
	